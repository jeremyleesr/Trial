<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Piano Hero – Stable Pitch Build</title>

<style>
html, body {
  margin: 0;
  padding: 0;
  background: #07160f;
  color: #d8ffe8;
  font-family: system-ui;
  overflow: hidden;
}

#ui {
  position: absolute;
  top: 12px;
  left: 12px;
  z-index: 10;
}

button {
  background: #2ecc71;
  border: none;
  border-radius: 12px;
  padding: 10px 18px;
  font-size: 18px;
  font-weight: 600;
}

#stats {
  margin-top: 10px;
  font-size: 14px;
  line-height: 1.4;
}

canvas {
  display: block;
}
</style>
</head>

<body>

<div id="ui">
  <button id="startBtn">Start</button>
  <div id="stats">
    Hz: --<br>
    Note: --<br>
    Last: --
  </div>
</div>

<canvas id="game"></canvas>

<script>
/* =====================
   CONFIG
===================== */
const NOTE_SPEED = 120;
const HIT_WINDOW_MS = 300;
const HIT_ZONE_WIDTH = 90;
const STAFF_RATIO = 0.20;
const RMS_GATE = 0.02;
const STABLE_FRAMES = 6;

/* =====================
   CANVAS
===================== */
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

function resize() {
  canvas.width = innerWidth;
  canvas.height = innerHeight;
}
resize();
addEventListener("resize", resize);

/* =====================
   NOTES
===================== */
const NOTES = [
  { note: "C4", freq: 261.63, offset: 0 },
  { note: "D4", freq: 293.66, offset: -1 },
  { note: "E4", freq: 329.63, offset: -2 },
  { note: "F4", freq: 349.23, offset: -3 },
  { note: "G4", freq: 392.00, offset: -4 }
];

function noteY(n, top, h) {
  const spacing = h / 8;
  return top + h / 2 + n.offset * spacing;
}

/* =====================
   GAME STATE
===================== */
let notes = [];
let running = false;
let lastSpawn = 0;
let lastTime = 0;
let detected = null;
let stableCount = 0;
let lastResult = "--";

/* =====================
   AUDIO (AUTOCORRELATION)
===================== */
let audioCtx, analyser, buffer;

async function startAudio() {
  audioCtx = new AudioContext();
  const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
  const source = audioCtx.createMediaStreamSource(stream);

  analyser = audioCtx.createAnalyser();
  analyser.fftSize = 2048;
  buffer = new Float32Array(analyser.fftSize);

  source.connect(analyser);
}

function autoCorrelate(buf, sampleRate) {
  let rms = 0;
  for (let i = 0; i < buf.length; i++) rms += buf[i] * buf[i];
  rms = Math.sqrt(rms / buf.length);
  if (rms < RMS_GATE) return null;

  let bestOffset = -1;
  let bestCorr = 0;

  for (let offset = 40; offset < 1000; offset++) {
    let corr = 0;
    for (let i = 0; i < buf.length - offset; i++) {
      corr += buf[i] * buf[i + offset];
    }
    if (corr > bestCorr) {
      bestCorr = corr;
      bestOffset = offset;
    }
  }

  if (bestOffset === -1) return null;
  return sampleRate / bestOffset;
}

function detectPitch() {
  analyser.getFloatTimeDomainData(buffer);
  const freq = autoCorrelate(buffer, audioCtx.sampleRate);
  if (!freq) {
    detected = null;
    stableCount = 0;
    return;
  }

  // Clamp octave range (C4–G4)
  let best = null;
  let diff = Infinity;
  for (const n of NOTES) {
    const d = Math.abs(freq - n.freq);
    if (d < diff) {
      diff = d;
      best = n;
    }
  }

  if (diff < 25) {
    stableCount++;
    if (stableCount >= STABLE_FRAMES) detected = best;
  } else {
    stableCount = 0;
    detected = null;
  }
}

/* =====================
   NOTES
===================== */
function spawnNote() {
  notes.push({
    ...NOTES[Math.floor(Math.random() * NOTES.length)],
    x: canvas.width + 40,
    hit: false,
    judged: false
  });
}

/* =====================
   LOOP
===================== */
function loop(ts) {
  if (!running) return;
  const dt = (ts - lastTime) / 1000;
  lastTime = ts;

  detectPitch();

  if (ts - lastSpawn > 1400) {
    spawnNote();
    lastSpawn = ts;
  }

  notes.forEach(n => n.x -= NOTE_SPEED * dt);

  const staffH = canvas.height * STAFF_RATIO;
  const staffTop = canvas.height - staffH;
  const hitX = canvas.width / 2;

  notes.forEach(n => {
    if (n.judged) return;

    if (Math.abs(n.x - hitX) < HIT_ZONE_WIDTH / 2) {
      if (detected && detected.note === n.note) {
        n.hit = true;
        n.judged = true;
        lastResult = "HIT";
      }
    }

    if (n.x < hitX - HIT_ZONE_WIDTH && !n.judged) {
      n.judged = true;
      lastResult = "MISS";
    }
  });

  draw();
  requestAnimationFrame(loop);
}

/* =====================
   DRAW
===================== */
function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  const staffH = canvas.height * STAFF_RATIO;
  const staffTop = canvas.height - staffH;

  ctx.fillStyle = "rgba(0,255,120,0.18)";
  ctx.fillRect(canvas.width/2 - HIT_ZONE_WIDTH/2, staffTop, HIT_ZONE_WIDTH, staffH);

  ctx.strokeStyle = "#cceedd";
  for (let i = 2; i <= 6; i++) {
    const y = staffTop + i * (staffH / 8);
    ctx.beginPath();
    ctx.moveTo(0, y);
    ctx.lineTo(canvas.width, y);
    ctx.stroke();
  }

  notes.forEach(n => {
    ctx.fillStyle = n.hit ? "#2ecc71" : "#fff";
    ctx.beginPath();
    ctx.arc(n.x, noteY(n, staffTop, staffH), 10, 0, Math.PI*2);
    ctx.fill();
  });

  document.getElementById("stats").innerHTML =
    `Hz: ${detected ? detected.freq?.toFixed?.(1) ?? "--" : "--"}<br>
     Note: ${detected ? detected.note : "--"}<br>
     Last: ${lastResult}`;
}

/* =====================
   START
===================== */
document.getElementById("startBtn").onclick = async () => {
  if (running) return;
  await startAudio();
  running = true;
  lastTime = performance.now();
  requestAnimationFrame(loop);
};
</script>

</body>
</html>
